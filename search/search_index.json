{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to FlaxSave","text":"<p>Get FlaxSave up and running in a few simple steps. This guide assumes that you already installed the plugin into your project. If not, get FlaxSave here.</p> <p>Guides</p> <p>If you're looking for more detailed guides, check out the Manual.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#save-settings","title":"Save Settings","text":"<p>The save system uses a central FlaxSaveSettings asset to manage paths, file extensions, versioning and the auto-save configuration. </p> <p>This allows you to customize properties and behaviours to your project needs, without touching a single line of code.</p> <p>To create and use a save settings asset:</p> <ul> <li>In the content window, <code>right click &gt; New &gt; Flax Save &gt; Settings</code></li> <li>Open your projects <code>GameSettigs</code></li> <li>Add the new asset to <code>GameSettings &gt; Other Settings &gt; Custom Settings</code></li> </ul> <p></p> <p>Save settings need to be linked in the <code>GameSettings</code> asset to take effect. This allows you to create multiple save settings assets for quickly testing different configurations, i.e. <code>DebugSettings</code> with shorter auto-save intervals and <code>ReleaseSettings</code> for the final game.</p> <p>Default Settings</p> <p>If you don't link any settings asset in <code>GameSettings</code>, FlaxSave will fall back to its default settings.</p> <p>Settings Key</p> <p>While Flax allows you to assign a \"Key\" to custom settings, FlaxSave identifies its settings by type. You can leave the key field at default or rename it however you like.</p> <p></p>"},{"location":"#save-actor-state","title":"Save Actor State","text":"<p>The core design of FlaxSave is that every actor (and its hierarchy) should be self-contained. Each object handles its own data-serialization.</p> <p>To make an object savable, you simply hook it into the SaveManager events, like this:</p> C#<pre><code>...\nusing FlaxSave;\n\npublic class SavableTransform : Script\n{\n    public void SaveTransform(Dictionary&lt;Guid, string&gt; savegame)\n    {\n        // Savegame files are Json-based, so serialize the transform to json\n        string data = JsonSerializer.Serialize(Actor.Transform);\n\n        // Add or update the savegame entry for this object using its unique ID\n        savegame[ID] = data;\n    }\n\n\n    public override void OnEnable()\n    {\n        // Subscribe to the save event. \n        // This event is dispatched during manual or auto-save,\n        // when all active objects are asked to provide their save data.\n        SaveManager.Instance.OnSaving += SaveTransform;\n    }\n\n\n    public override void OnDisable()\n    {\n        // Don't forget to unsubscribe your methods from events!\n        SaveManager.Instance.OnSaving -= SaveTransform;\n    }\n}\n</code></pre> <p>Detailed Examples</p> <p>Check out for more detailed and advanced examples in your plugin folder  <code>FlaxSave &gt; Source &gt; FlaxSaveExamples &gt; Scripts</code></p> <p></p>"},{"location":"#load-actor-state","title":"Load Actor State","text":"<p>The core design of FlaxSave is that every actor (and its hierarchy) should be self-contained. Each object handles its own data-serialization.</p> <p>To make an object load it's previous state, you simply call the SaveManager api, like this:</p> C#<pre><code>...\nusing FlaxSave;\n\npublic class SavableTransform : Script\n{\n    public override void OnEnable()\n    {\n        // Load the state from the currently loaded savegame. \n        // At this point the savegame should have been loaded.\n        string data = SaveManager.Instance.GetSaveData(ID);\n\n        if (string.IsNullOrEmpty(data))\n            return;\n\n        Transform savedTransform = JsonSerializer.Deserialize&lt;Transform&gt;(data);\n        Actor.Transform = savedTransform;\n    }\n}\n</code></pre> <p>Detailed Examples</p> <p>Check out for more detailed and advanced examples in your plugin folder  <code>FlaxSave &gt; Source &gt; FlaxSaveExamples &gt; Scripts</code></p> <p></p>"},{"location":"#saving-loading-to-disk","title":"Saving &amp; Loading to Disk","text":"<p>To trigger the actual file operations, you simply call the SaveManager api. The system handles the heavy lifting, like file I/O and threading, behind the scenes.</p> <p>This script demonstrates how dispatch save and load actions via key press.</p> C#<pre><code>...\nusing FlaxSave;\n\n/// &lt;summary&gt;Example for quick-save and quick-load setup&lt;/summary&gt;\npublic class Dispatch : Script\n{\n    private SaveManager saveManager =&gt; SaveManager.Instance;\n\n    /// &lt;inheritdoc/&gt;\n    public override void OnUpdate()\n    {\n        // Saves the current game state\n        if (Input.GetKeyDown(KeyboardKeys.F5))\n            saveManager.RequestGameSave();\n\n        // Loads the latest savegame. \n        // Savegames have to be loaded before actor initilization.\n        if (Input.GetKeyDown(KeyboardKeys.F6))\n            saveManager.RequestGameLoad(saveManager.SaveMetas[^1].SaveName);\n    }\n}\n</code></pre> <p>The SaveMetas List</p> <p>The <code>SaveMetas</code> list is ordered chronologically. <code>SaveMetas[0]</code> is the oldest save, while <code>SaveMetas[^1]</code> (or <code>SaveMetas.Last()</code>) is always the newest savegame.</p> <p></p>"},{"location":"#good-to-know","title":"Good to know","text":""},{"location":"#core-concepts","title":"Core Concepts","text":"<p>To get the most out of this quick start guide, it helps to understand the three pillars of the system</p> <ul> <li>The Save Manager Is the central hub. Use this to trigger saves, loads, read data and listen to global events.</li> <li>Save Settings The editor-configured settings that are used by the save system.</li> <li>Metadata Is how the system identifies and organizes save files for you to create menus around it.</li> </ul>"},{"location":"#timing-is-everything","title":"Timing is Everything","text":"<p>Savegames should generally be loaded before actor initialization (i.e. before a level transition or before OnStart). </p> <p>If you load a save while a level is already running, you need to ensure your scripts are listening to the OnLoaded event to update their states.</p>"},{"location":"#threading-safety","title":"Threading &amp; Safety","text":"<p>FlaxSave is asynchronous by design. Most operations happen on a background thread, to prevent stuttering and frame drops during gameplay.</p> <ul> <li>Always remember When gathering data in OnSaving, it's ok to read from the scene, but don't modify it.</li> <li>Use OnSaved and OnLoaded for UI updates and other scene modifications. Also, consider using InvokeOnSaved, InvokeOnLoaded and InvokeOnDeleted for one-time updates.</li> </ul>"},{"location":"Api/","title":"Welcome to the FlaxSave API","text":"<p>Welcome to the FlaxSave C# API. This section of the documentation provides the technical specification for all user-facing classes and methods within FlaxSave. </p> If you're looking for a step-by-step guide on setting up the plugin, check out the Manual"},{"location":"Api/#namespaces","title":"Namespaces","text":"<p>The API is organized by namespaces and you'll find that the primary namespace <code>FlaxSave</code> contains the core logic and managers.</p> Class Description SaveManager The main entry point. Handles save and load request, threading and task queue. SaveMeta Data model for save file information (names, dates, custom metadata) FlaxSaveSettings The engine integrated configuration asset for paths, versioning and auto-save settings. ISavableAsset Base interface for serializable assets, like engine settings and global configuration."},{"location":"Api/FlaxSaveSettings/","title":"Class FlaxSaveSettings","text":"<p>The <code>FlaxSaveSettings</code> class acts as the central configuration hub for the save system. It manages everything from file paths and extensions, save data versioning, to the timing logic of the auto-save feature.</p> <p><code>FlaxSaveSettings</code> is used for the Save Settings asset and configured in-editor.</p>"},{"location":"Api/FlaxSaveSettings/#properties","title":"Properties","text":""},{"location":"Api/FlaxSaveSettings/#assets","title":"Assets","text":"<p>A list of registered <code>ISavable</code> assets. These are automatically serialized during <code>RequestAssetSave</code> and reloaded, when FlaxSave is initialized.</p> <ul> <li>Type: <code>List&lt;JsonAssetReference&lt;ISavableAsset&gt;&gt;</code></li> <li>Access: <code>get</code></li> </ul> <p>Editor protection</p> <p>To prevent data loss, this list is not automatically loaded in editor (unless specified otherwise). Loading assets overwrites the asset state in your project. See <code>SkipLoadingSettingsInEditor</code></p> <p>Tip</p> <p>This list can be configured in-editor with the Settings asset</p> <p></p>"},{"location":"Api/FlaxSaveSettings/#autosaveintervalminutes","title":"AutoSaveIntervalMinutes","text":"<p>The auto-save interval, converted to minutes</p> <ul> <li>Type: <code>int</code></li> <li>Access: <code>get</code></li> <li>Note: The auto save interval can be configured in-editor with the the Settings asset</li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#autosaveintervalseconds","title":"AutoSaveIntervalSeconds","text":"<p>The auto-save interval, converted to seconds</p> <ul> <li>Type: <code>int</code></li> <li>Access: <code>get</code></li> <li>Note: The auto save interval can be configured in-editor with the the Settings asset</li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#autosaveintervalmilliseconds","title":"AutoSaveIntervalMilliseconds","text":"<p>The auto-save interval, converted to milliseconds</p> <ul> <li>Type: <code>int</code></li> <li>Access: <code>get</code></li> <li>Note: The auto save interval can be configured in-editor with the the Settings asset</li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#autosave","title":"AutoSave","text":"<p>Enables or disables the auto-save feature.</p> <ul> <li>Type: <code>bool</code></li> <li>Access: <code>get</code></li> <li>Note: The auto save interval can be configured in-editor with the the Settings asset</li> </ul> <p>Info</p> <p>The auto-save feature can be switched on and off during runtime via <code>SetAutoSaveActive</code></p> <p></p>"},{"location":"Api/FlaxSaveSettings/#skiploadingsettingsineditor","title":"SkipLoadingSettingsInEditor","text":"<p>Enables or disable automatic asset loading during system initilization in-editor. The runtime is not affected by this setting and assets are always loaded in-game.</p> <ul> <li>Type: <code>bool</code></li> <li>Access: <code>get</code></li> <li>Note: Auto asset loading can be configured in-editor with the the Settings asset</li> </ul> <p>Editor data loss risk</p> <p>If set to <code>false</code>, the system will override your projects assets with data from the save folder. In the editor, this permanently modifies project assets. Proceed with caution.</p> <p></p>"},{"location":"Api/FlaxSaveSettings/#savegameversion","title":"SavegameVersion","text":"<p>The current version of your projects data scheme</p> <ul> <li>Type: <code>bool</code></li> <li>Access: <code>get</code></li> </ul> <p>Versioning Strategy</p> <p>It's best pratice to increment this version whenever you make breaking changes to your player data or <code>ISavableAsset</code> structures. This allows you to write checks and warn players about potential changes via UI notifications.</p> <p></p>"},{"location":"Api/FlaxSaveSettings/#savegamedirectory","title":"SavegameDirectory","text":"<p>Gets the absolute path of the save directory on disk</p> <ul> <li>Type: <code>string</code></li> <li>Access: <code>get</code></li> <li>Note: This directory can be opened via the Settings asset <code>Open Directory</code> button</li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#savegamemetafile","title":"SavegameMetaFile","text":"<p>Gets the absolute path of the specific file containing the <code>SaveMeta</code> collection</p> <ul> <li>Type: <code>string</code></li> <li>Access: <code>get</code></li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#settingsfile","title":"SettingsFile","text":"<p>Gets the absolute path of the file, where global <code>ISavable</code> data is stored</p> <ul> <li>Type: <code>string</code></li> <li>Access: <code>get</code></li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#savegamefileextension","title":"SavegameFileExtension","text":"<p>The valid file extension used for save files, i.e <code>.save</code> or <code>.data</code></p> <ul> <li>Type: <code>string</code></li> <li>Access: <code>get</code></li> <li>Note: The save file extension can be configured in-editor with the the Settings asset</li> </ul> <p></p>"},{"location":"Api/FlaxSaveSettings/#methods","title":"Methods","text":""},{"location":"Api/FlaxSaveSettings/#getsavefilepath","title":"GetSaveFilePath","text":"<p>This method constructs the full and valid path to a specific save file</p> Parameter Type Description savegameName string The name of the save file, usualy found in a <code>SaveMeta.SaveName</code> <p>|Returns||Description| |---|---| |string|The full and valid path to a specifc save file|</p> <p>How it works: This is a convinience method, that combines the savegame path with a save file name and returns a vaild path to that file.</p> <p></p>"},{"location":"Api/FlaxSaveSettings/#opendirectory","title":"OpenDirectory","text":"<p>Opens the OS file explorer at the savegame directory location</p> Parameter Type Description (none) <p>How it works: This method opens a new system explorer window at the savegame directory.</p> <p>Tip</p> <p>You don't need to call this code during development, the save directory can simply be opened via the Settings asset <code>Open Directory</code> button</p> <p></p>"},{"location":"Api/ISavableAsset/","title":"interface ISavableAsset","text":"<p>The <code>ISavable</code> interface allows you to connect JSON assets directly to the save system. This is ideal for global data that should persist across different levels and sessions, not bound to any actors or scenes.</p> <p>Any class implementing this interface and registered in your FlaxSaveSettings will be automatically managed by the SaveManager.</p>"},{"location":"Api/ISavableAsset/#methods","title":"Methods","text":""},{"location":"Api/ISavableAsset/#saveaction","title":"SaveAction","text":"<p>This method is called immediately before the assets instance is serialized and written to disk.</p> <p>Purpose: Use this to prepare your asset instance. It's the place, where you pull live values from your game and store them in the assets variables, so they are up-to-date for saving.</p> <p></p>"},{"location":"Api/ISavableAsset/#loadaction","title":"LoadAction","text":"<p>This methods is called immedialty after the assets instance has successfully been loaded from disk.</p> <p>Purpose: Use this to distribute your data. Once the values has been loaded into the asset, you can use this method to update other systems or engine settings with the new values.</p> <p></p>"},{"location":"Api/ISavableAsset/#how-it-works","title":"How it works","text":"<p>When the <code>SaveManager</code> initializes, it automatically calls <code>RequestAssetLoad</code> for all registered assets in the SaveSettings. This ensures your global settings are ready before the first scene is loaded.</p> <p>Editor protection</p> <p>To prevent accidental data loss while working in the Flax Editor, automatic assets loading is disabled by default during edit-time. This behaviour can be configured in SaveSettings asset</p>"},{"location":"Api/ISavableAsset/#deep-serialization","title":"Deep Serialization","text":"<p>An important aspect of <code>ISavable</code> asset is that the entire asset instance is serialized and deserialized. With that, public fields and properties are directly saved to disk. During loading, the active state of the asset instance is replaced with the loaded data from disk.</p> <p>You can simply define any important configuration data as field or property in your class and the rest is handled by the save system.</p>"},{"location":"Api/ISavableAsset/#examples","title":"Examples","text":"<p>The following example class can be used as JSON asset and registered in the SaveSettings.</p> C#<pre><code>using FlaxEngine;\n\nnamespace FlaxSave;\n\npublic class SavableGraphics : ISavableAsset\n{\n    // Important configuration data for the game\n    public Float2 ScreenSize;\n    public bool UseVSync;\n\n    // Pull the current screen settings from engine,\n    // before everything is written to disk\n    public void SaveAction()\n    {\n        UseVSync = Graphics.UseVSync;\n        ScreenSize = Screen.Size;\n    }\n\n    // Apply settings to the engine, after everything\n    // was loaded from disk\n    public void LoadAction()\n    {\n        Graphics.UseVSync = UseVSync;\n        Screen.Size = ScreenSize;\n    }\n}\n</code></pre> <p>No manual parsing</p> <p>Contrary to savegames, assets don't need handle their data serialization. <code>public</code> fields and properties are automatically handled by the system.</p>"},{"location":"Api/SaveManager/","title":"Class SaveManager","text":"<p>The <code>SaveManager</code> is the central hub for saving and loading game and asset states. The class uses a singleton pattern, to provide easy, global accessibility for active savegames and everything necessary around it.</p>"},{"location":"Api/SaveManager/#properties","title":"Properties","text":""},{"location":"Api/SaveManager/#instance","title":"Instance","text":"<p>Allows for easy access to the singleton instance of the SaveManager. Returns null, if the plugin wasn't loaded, yet.</p> <ul> <li>Type: <code>FlaxSave.SaveManager</code></li> <li>Access: <code>static</code></li> </ul> <p>C#<pre><code>var manager = SaveManager.Instance;\n</code></pre> </p>"},{"location":"Api/SaveManager/#pluginversion","title":"PluginVersion","text":"<p>Gets the current version of the plugin. This property can be used to verify engine compatibility or to check for available features.  </p> <ul> <li>Type: <code>System.Version</code></li> <li>Access: <code>static</code></li> </ul> <p><code>PluginVersion</code> vs. <code>SavegameVersion</code></p> <p>The <code>PluginVersion</code> property tracks the software version of the plugin itself. For tracking data schema changes and handling migrations of individual save files, use the versioning system via SavegameVersion within the SaveMeta.</p> <p></p>"},{"location":"Api/SaveManager/#savemetas","title":"SaveMetas","text":"<p>Provides a chronological list of all detected save games. This collection is primarily used to populate \"Load Game\" menus with metadata (i.e. timestamps, playtimes, or names).</p> <ul> <li>Type: <code>List&lt;SaveMeta&gt;</code></li> <li>Sorting: The list is ordered chronologically, where the oldest save game is at index <code>0</code>.</li> </ul> <p>Tip</p> <p>To load a specific savegame, retrive its SaveName from the list and pass it to the loading system.</p> <p>C#<pre><code>// Load the oldest savegame\nSaveMeta oldestSave = SaveManager.Instance.SaveMetas[0];\nstring saveName = oldestSave.SaveName;\nSaveManager.Instance.RequestGameLoad(saveName);\n\n// Load the newest savegame\nSaveMeta newestSave = SaveManager.Instance.SaveMetas[^1];\nstring saveName = oldestSave.SaveName;\nSaveManager.Instance.RequestGameLoad(saveName);\n</code></pre> </p>"},{"location":"Api/SaveManager/#savesettings","title":"SaveSettings","text":"<p>Provides access to the active save settings configuration. This property acts as the central hub for project-specific rules, such as save data versioning and file paths. The <code>SaveManager</code> retrieves these settings from the FlaxSaveSettings asset within your project's <code>GameSettings</code> asset.</p> <ul> <li>Type: <code>FlaxSave.FlaxSaveSettings</code></li> </ul> <p>C#<pre><code>// Compare the current savegame version to the oldest savegame\nVersion settingsVersion = SaveManager.Instance.SaveSettings.SavegameVersion;\nVersion saveVersion = SaveManager.Instance.SaveMetas[0].SaveVersion;\n\nif(saveVersion != settingsVersion)\n    Debug.Log(\"The savegame seems to be older. Proceed with caution!\");\n</code></pre> </p>"},{"location":"Api/SaveManager/#isbusy","title":"IsBusy","text":"<p>Indicates whether the save system is actively performing a background task, like saving, loading or deleting.</p> <ul> <li>Type: <code>bool</code></li> </ul> <p></p>"},{"location":"Api/SaveManager/#events","title":"Events","text":""},{"location":"Api/SaveManager/#onsaving","title":"OnSaving","text":"<p>This event is triggered immediatly after a save operation is initiated, but before any data is being written to disk. It acts as a data collection hook for all persistent objects within your project.</p> <ul> <li>Type: <code>Action&lt;Dictionary&lt;Guid, string&gt;&gt;</code></li> <li>Payload: The active save data dictionary to be populated</li> </ul> <p>Performance: Non-Blocking</p> <p>This event does not hinder gameplay. You can serialize large amounts of data without causing frame drops or \"hitching.\"</p> <p>Read, don't write</p> <p>This event runs on a background thread, while the regular game keeps running on the main thread. Flax does not allow scene changes from a background thread.</p> <p>It is safe to read values from Actors and Scripts (i.e. <code>Actor.Position</code>, <code>Light.Brightness</code>, <code>Image.Visible</code>, etc), but avoid changing values in the scene or updating the UI (i.e. don't do <code>player.Health = 100</code> or <code>label.Text = \"Saving...\"</code>) from your listener method.</p> <p>C#<pre><code>private void CollectMyData(Dictionary&lt;Guid, string&gt; saveData)\n{\n    // Only read data here\n    Vector3 myPosition = Actor.Position;\n    saveData[ID] = JsonSerializer.Serialize(myPosition);\n}\n\npublic override void OnEnable()\n{\n    SaveManager.Instance.OnSaving += CollectMyData;\n}\n\npublic override void OnDisable()\n{\n    // Don't forget to unsubscribe your methods from events!\n    SaveManager.Instance.OnSaving -= CollectMyData;\n}\n</code></pre> </p>"},{"location":"Api/SaveManager/#onsaved","title":"OnSaved","text":"<p>This event is triggered after the background save operation has been completed and all the data has been written to disk.</p> <ul> <li>Type: <code>Action</code></li> <li>See also <code>InvokeOnSaved</code></li> </ul> <p>This event can be used to update the in-game ui to give a hint, that game progression has been saved.</p> <p>Main thread dispatch</p> <p>Unlike OnSaving, this event is dispatched back on the main thread. This allows you to safely call UI methods and interact with engine components without thead-safety concerns.</p> <p></p>"},{"location":"Api/SaveManager/#onloaded","title":"OnLoaded","text":"<p>This event is triggered after the background loading operation has been completed and all the data is available for further utilization.</p> <ul> <li>Type: <code>Action</code></li> <li>See also <code>InvokeOnLoaded</code></li> </ul> <p>Main thread dispatch</p> <p>Unlike OnSaving, this event is dispatched back on the main thread. This allows you to safely set object data and interact with engine components without thead-safety concerns.</p> <p>C#<pre><code>private void SpawnLevels()\n{\n    Level.LoadScene(GameSettings.Load().FirstScene);\n}\n\npublic override void OnEnable()\n{\n    SaveManager.Instance.OnLoaded += SpawnLevels;\n}\n\npublic override void OnDisable()\n{\n    // Don't forget to unsubscribe your methods from events!\n    SaveManager.Instance.OnLoaded -= SpawnLevels;\n}\n</code></pre> </p>"},{"location":"Api/SaveManager/#ondeleted","title":"OnDeleted","text":"<p>This event is triggered after the background delete operation has been completed and a savegame has been removed from disk.</p> <ul> <li>Type: <code>Action</code></li> <li>See also <code>InvokeOnDeleted</code></li> </ul> <p>This event can be used to refresh the in-game ui. Since the file is gone, you'll want to update the list of available saves, so the player doesn't try to pick a deleted entry. </p> <p>Main thread dispatch</p> <p>Unlike OnSaving, this event is dispatched back on the main thread. This allows you to safely call UI methods and interact with engine components without thead-safety concerns.</p> <p></p>"},{"location":"Api/SaveManager/#methods","title":"Methods","text":""},{"location":"Api/SaveManager/#setsavedata","title":"SetSaveData","text":"<p>Provides thread-safe write access to the savegame data for a specific component. This method updates the in-memory save state without writing the save to disk.</p> Parameter Type Description id Guid Unique identifier of a save component content string Save data associated with the component as a serialized JSON-string <p>How it works: This method writes the provided serialized data to the ActiveSaveData under the specified component id.  </p>If any entry with the same id exists, it is overriden. The caller is responsible for providing correctly serialized content. <p>In-Memory only</p> <p>This method does not trigger a write-to-disk operation. Call the RequestGameSave method to write the updated data to disk.</p> C#<pre><code>string newData = JsonSerializer.Serialize(Actor.Transform);\nSaveManager.Instance.SetSaveData(ID, newData);\n</code></pre> <p></p>"},{"location":"Api/SaveManager/#getsavedata","title":"GetSaveData","text":"<p>Provides thread-safe read access to the savegame data for a specific component. This method reads the in-memory save state without loading a save from disk.</p> Parameter Type Description id Guid Unique identifier of a save component Returns Description string The data associated with the component as a serialized JSON-string <p>How it works: This method retrieves the serialized data associated with a specific component id from the ActiveSaveData.  </p>The caller is responsible for deserializing the string to it's original contents. If no entry exists for the given ID, the method throws a <code>KeyNotFoundException</code>. <p>In-Memory only</p> <p>This method does not trigger a read-from-disk operation. Call the RequestGameLoad method to read serialized data from disk.</p> C#<pre><code>string data = SaveManager.Instance.GetSaveData(ID);\n\nif(data != null)\n    Transform savedTransform = JsonSerializer.Deserialize&lt;Transform&gt;(data);\n</code></pre> <p></p>"},{"location":"Api/SaveManager/#removesavedata","title":"RemoveSaveData","text":"<p>Provides thread-safe removal of a specific entry from the active in-memory savegame data. The removal is applied to disk during the next save operation.</p> Parameter Type Description id Guid Unique identifier of a save component <p>How it works: This method removes the serialized data associated with the specific component id from the ActiveSaveData. If no entry exists for the given id, the call has no effect.</p> <p>Forgotten, but not gone</p> <p>A component might re-add itself to ActiveSaveData during the OnSaving event or via SetSaveData. Ensure the component is disabled or removed if permanent deletion is intended.</p> <p>In-Memory only</p> <p>This method only affects the current active in-memory save state. Call the RequestGameSave method to write the updated data to disk.</p> <p></p>"},{"location":"Api/SaveManager/#clearsavedata","title":"ClearSaveData","text":"<p>Provides thread-safe for clearing all entries from the active in-memory savegame data.</p> Parameter Type Description (none) <p>How it works: This method clears all serialized component data from ActiveSaveData. Unsaved runtime progress is lost, unless a save is performed before clearing.  </p> This method does not affect existing save files. The cleared state is written to disk during the next save operation. <p>New Game / New Game+</p> <p>This method is useful for starting a new playthrough, without restarting the application. It ensures that no persistent runtime state is carried over.</p> <p>All unsaved progress will be lost</p> <p>Clearing the active save data discards all unsaved progress. Consider promting the player to save the current state before calling this method.</p> <p></p>"},{"location":"Api/SaveManager/#requestgamesave","title":"RequestGameSave","text":"<p>Queues a request to save the current game state to the disk. To prevent performance issues, the save operation runs on a background thread.</p> Parameter Type Description savegameName string The friendly name shown in a load menu customMetaData object (Optional) Any extra data you want to attach to the SaveMeta (like player progress or current quest) for display menus <p>How it works: This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.</p> <p>Anti-Spam Protection</p> <p>The queue only holds one save request at a time. If a player \"hammers\" the save button while the system is busy, only the most recent request will be executed once the current task finishes. This keeps the disk and performance clean.</p> <p>C#<pre><code>// Simple save with a custom name\nSaveManager.Instance.RequestGameSave(\"before the boss\");\n\n// Save with custom metadata (i.e. for your Load Menu)\nvar meta = new MyProjectMeta { PlayerLevel = 5, CurrentQuest = \"Dungeon Boss\" };\nSaveManager.Instance.RequestGameSave(\"before the boss\", meta);\n</code></pre> </p>"},{"location":"Api/SaveManager/#requestgamesaveoverwrite","title":"RequestGameSaveOverwrite","text":"<p>Queues a request to save the current game state with an existing SaveMetas entry to the disk. To prevent performance issues, the save operation runs on a background thread.</p> Parameter Type Description index int The index of the SaveMetas entry to overwrite customMetaData object (Optional) Any extra data you want to attach to the SaveMeta (like player progress or current quest) for display menus <p>How it works: During execution, this method creates a new save file and a corresponding SaveMetas entry. Once the new data is successfully writen, the system deletes the old save file and replaces the SaveMetas entry at the specified index. </p> <p>The <code>DisplayName</code> property and SaveMetas entry index remain unchanged, keeping the appearance in your UI list consistent and providing a seamless updating experience.</p> <p>This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.</p> <p>Anti-Spam Protection</p> <p>The queue only holds one save request at a time. If a player \"hammers\" the save button while the system is busy, only the most recent request will be executed once the current task finishes. This keeps the disk and performance clean.</p> <p>C#<pre><code>// Simple save overwrite\nSaveManager.Instance.RequestGameSaveOverwrite(index);\n\n// Save with custom metadata (i.e. for your Load Menu)\nvar meta = new MyProjectMeta { PlayerLevel = 5, CurrentQuest = \"Dungeon Boss\" };\nSaveManager.Instance.RequestGameSaveOverwrite(index, meta);\n</code></pre> </p>"},{"location":"Api/SaveManager/#requestgameload","title":"RequestGameLoad","text":"<p>Queues a request to load a specific savegame from disk. To prevent performance issues, the load operation runs on a background thread.</p> Parameter Type Description saveName string Unique identifier of the save slot (typically a GUID-like string) <p>How it works: This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.</p> <p><code>SaveName</code> vs. <code>DisplayName</code></p> <p>The names of save files are guid strings and are stored in the corresponding SaveMeta as the <code>SaveName</code> property. The <code>DisplayName</code> property, on the other hand, contains the friendly name shown in a load menu.</p> <p>C#<pre><code>string saveName = SaveManager.Instance.SaveMetas[0].SaveName;\nSaveManager.Instance.RequestGameLoad(saveName);\n</code></pre> </p>"},{"location":"Api/SaveManager/#requestgamedelete","title":"RequestGameDelete","text":"<p>Queues a request to delete a specific savegame from disk. This operation runs on a background thread.</p> Parameter Type Description saveName string Unique identifier of the save slot (typically a GUID-like string) <p>How it works: This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.</p> <p>Irreversible Operation</p> <p>Deleting a savegame permanently removes both the save file and the SaveMetas. Proceed with caution. Consider promting the player for confirmation. The operation is irreversible unless the user manually restores the file and SaveMetas entry. </p> <p></p>"},{"location":"Api/SaveManager/#requestassetssave","title":"RequestAssetsSave","text":"<p>Queues a request to save all assets defined in FlaxSaveSettings to disk. To prevent performance issues, the save operation runs on a background thread.</p> Parameter Type Description (none) <p>How it works: This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.</p> <p>Registered assets only</p> <p>Only assets explicitly registered in the active <code>FlaxSaveSettings</code> asset are processed. Other assets are ignored. Asset saving is independent from game saves, soSaveMetas and savegames are unaffected by this method.</p> <p>Tip</p> <p>This system is intended for engine settings, global configuration and persistent editor/runtime assets.</p> <p></p>"},{"location":"Api/SaveManager/#requestassetsload","title":"RequestAssetsLoad","text":"<p>Queues a request to load the states of all assets defined in FlaxSaveSettings from disk. To prevent performance issues, the loading operation runs on a background thread.</p> Parameter Type Description (none) <p>How it works: This method uses a queue system. If you call this method while a save or load operation is already in progress, the request will be queued and executed as soon as possible.  </p>During execution, the system will iterate over all asset references registered in FlaxSaveSettings and overwrites their current in-memory state with the serialized data from disk. <p>In-Game behaviour: This method is automatically executed during systme initialization, to ensure that engine settings and global configuration is available as soon as possible.</p> <p>Editor behaviour: By default, this method is not executed automatically in the editor to prevent accidental permanent modification of asset files. Asset loading in the editor can be explicitly enabled in FlaxSaveSettings.</p> <p>Registered assets only</p> <p>Only assets explicitly registered in the active <code>FlaxSaveSettings</code> asset are processed. Other assets are ignored. Asset loading is independent from game saves, soSaveMetas and savegames are unaffected by this method.</p> <p>Editor data loss risk</p> <p>Loading assets overwrites the current asset state. In the editor, this permanently modifies project assets. Proceed with caution.</p> <p></p>"},{"location":"Api/SaveManager/#setautosaveactive","title":"SetAutoSaveActive","text":"<p>Enables and disables the auto-save feature.</p> Parameter Type Description isActive bool The new auto-save state (<code>true</code> = enabled, <code>false</code> = disabled) <p>How it works: This method toggles the internal auto-save system. When enabled, the <code>SaveManager</code> will trigger save operations at the configured AutoSaveInterval.  </p>Enabling auto-save will not immediatly trigger a save operation, but wait until the configured interval is over. Disabling auto-save does not cancel currently running save operations. <p></p>"},{"location":"Api/SaveManager/#opensavedirectory","title":"OpenSaveDirectory","text":"<p>Opens the savegame directory in the systems file browser.</p> Parameter Type Description (none) <p>How it works: This method launches a new system browser window in the active directory used by FlaxSave.</p> <p>Location</p> <p>Savegames created in the Flax Editor are located in a different directory than savegames created in a packaged game build.</p> <p></p>"},{"location":"Api/SaveManager/#invokeonsaved","title":"InvokeOnSaved","text":"<p>Registers a specific action to be invoked the next time a save operation is completed. Once the action is invoked, it is automatically removed from queue.</p> Parameter Type Description action Action The action or logic that runs after the next successful save <p>How it works: Think of this as a one-time subscription. This method queues an action and executes it the next time the OnSaved event is triggered. </p> <p>This is convenient for temporary notifications or logic, that only matters for the current save request, such as showing a success message or closing a specific menu after saving.</p> C#<pre><code>public void Notification()\n{\n    Debug.Log(\"The game was successfully saved!\");\n}\n\npublic override void OnEnable()\n{\n    SaveManager.Instance.InvokeOnSaved(Notification);\n}\n</code></pre> <p></p>"},{"location":"Api/SaveManager/#invokeonloaded","title":"InvokeOnLoaded","text":"<p>Registers a specific action to be invoked the next time a load operation is completed. Once the action is invoked, it is automatically removed from queue.</p> Parameter Type Description action Action The action or logic that runs after the next successful loading <p>How it works: Think of this as a one-time subscription. This method queues an action and executes it next time the OnLoaded event is triggered.</p> <p>This is convenient for temporary logic or ui updates, that only matters for the current loading request, such as showing a success message or loading levels after the savegame loaded.</p> C#<pre><code>public override void OnUpdate()\n{\n    if (Input.GetKeyDown(KeyboardKeys.F9))\n    {\n        SaveManager.Instance.InvokeOnLoaded(SpawnLevels);\n        saveManager.RequestGameLoad(saveManager.SaveMetas[0].SaveName);\n    }\n}\n\nprivate void SpawnLevels()\n{\n    Level.LoadScene(GameSettings.Load().FirstScene);\n}\n</code></pre> <p></p>"},{"location":"Api/SaveManager/#invokeondeleted","title":"InvokeOnDeleted","text":"<p>Registers a specific action to be invoked the next time a delete operation is completed. Once the action is invoked, it is automatically removed from queue.</p> Parameter Type Description action Action The action or logic that runs after the next file deletion <p>How it works: Think of this as a one-time subscription. This method queues an action and executes it next time the OnDeleted event is triggered.</p> <p>This is convenient for temporary notifications or logic, that only matters for the current deletion request, such as showing a success message or closing a specific menu after deleting a save file.</p> C#<pre><code>public override void OnUpdate()\n{\n    if (Input.GetKeyDown(KeyboardKeys.F11))\n    {\n        SaveManager.Instance.InvokeOnDeleted(Notification);\n        saveManager.RequestGameDelete(saveManager.SaveMetas[0].SaveName);\n    }\n}\n\npublic void Notification()\n{\n    Debug.Log(\"The savegame was successfully removed!\");\n}\n</code></pre> <p></p>"},{"location":"Api/SaveMeta/","title":"Class SaveMeta","text":"<p>The <code>SaveMeta</code> class provdes a leightweight snapshot of a savegame's information. It allows you to display details, like save date, player name or progression in your UI, without having to load the entire save file into memory.</p> <p>An always up-to-date list of all available savegame metas is accessible via the SaveManager.</p>"},{"location":"Api/SaveMeta/#properties","title":"Properties","text":""},{"location":"Api/SaveMeta/#savename","title":"SaveName","text":"<p>The unique, internal identifier of save files on the disk, generated by <code>Guid</code>.</p> <ul> <li>Type: <code>string</code></li> <li>Note: Use this with RequestGameLoad or RequestGameDelete</li> </ul>"},{"location":"Api/SaveMeta/#displayname","title":"DisplayName","text":"<p>The friendly save name, provided when the save was created (i.e. \"before boss fight\")</p> <ul> <li>Type: <code>string</code></li> <li>Note: This is the primary name you should display in your Load/Save slots UI</li> </ul>"},{"location":"Api/SaveMeta/#saveversion","title":"SaveVersion","text":"<p>The version of your project's data scheme at the time this file was created</p> <ul> <li>Type: <code>System.Version</code></li> <li>Note: The version is pulled from the FlaxSaveSettings. It is vital for handling legacy save files, if your data structure changes during development.</li> </ul>"},{"location":"Api/SaveMeta/#savedate","title":"SaveDate","text":"<p>The exact timestemp of when the save file was created</p> <ul> <li>Type: <code>System.DateTime</code></li> <li>Note: Since <code>DateTime</code> is a raw format, you'll likely want to format it for UI, i.e. <code>SaveDate.ToString(\"g\")</code>, for a readable date and time</li> </ul> C#<pre><code>DateTime localTime = metaData.SaveDate.ToLocalTime();\nstring date = localTime.ToString(\"d\");\nstring time =  localTime.ToString(\"t\");\n\nDebug.Log(date + \", \" + time); // 01.01.2026, 13:27\n</code></pre>"},{"location":"Api/SaveMeta/#customdata","title":"CustomData","text":"<p>A custom data block for project specific metadata, that you want to show in the menu, i.e. the players skill level, current quest or the world location</p> <ul> <li>Type: <code>object</code></li> <li>Note: This is the data you pass into the <code>customMetaData</code> parameter of RequestGameSave</li> <li>Tip: To safely access this data, use GetCustomDataAs&lt; T &gt;</li> </ul>"},{"location":"Api/SaveMeta/#isautosave","title":"IsAutoSave","text":"<p>A flag that indicates if this file was created with the auto-save feature or manually by the player</p> <ul> <li>Type: <code>bool</code></li> <li>Tip: Use this to title UI slots as a localized version of \"Auto-Save\"</li> </ul>"},{"location":"Api/SaveMeta/#methods","title":"Methods","text":""},{"location":"Api/SaveMeta/#getcustomdataas-t","title":"GetCustomDataAs&lt; T &gt;","text":"<p>A helper method to safely cast your CustomData object back into its original class</p> Returns Description T The type you specified <p>How it works: Because CustomData is stored as a general object, you need to cast it to access your specific fields and variables, like <code>PlayerLevel</code>. This method does the type-check for you. If the data isn't the type you asked for, it returns <code>null</code> for classes or the default value for <code>struct</code>.</p> C#<pre><code>SaveMeta newestMeta = SaveManager.Instance.SaveMetas.Last();\nPlayerMeta myData = SaveMeta.GetCustomDataAs&lt;PlayerMeta&gt;();\n\nif(myData != null)\n    Debug.Log(\"Player Level is \" + myData.PlayerLevel);\n</code></pre>"},{"location":"Manual/","title":"Welcome to FlaxSave","text":"<p>Welcome to FlaxSave - A modular, component based save system for the Flax Engine</p> <p>This system is designed to provide a high performance, multi-threaded save system, that stays out of you way and keeps your gameplay smooth.</p>"},{"location":"Manual/#how-it-works","title":"How it works","text":"<p>The FlaxSave system is designed to be Plug&amp;Play. Once the plugin is added to your project, a global instance of the <code>SaveManager</code> is automatically instantiated before any scene is loaded, ensuring that the save infrastructure is always ready.</p>"},{"location":"Manual/#1-initialization-startup-phase","title":"1. Initialization (Startup Phase)","text":"<p>As soon as your game starts, the <code>SaveManager</code> performs two critical tasks to ensure a smooth user (you) experience.</p> <ul> <li>Metadata Detection The system scans the save directory and collects every available <code>SaveMeta</code>. This allows your games UI to display save slots instantly, without any hiccups.</li> <li>Global Configuration The system loads all registered <code>ISavableAssets</code>. This ensures that global configuration, like graphics, keybinds, audio, etc, are applied before the player even reaches the main menu.</li> </ul>"},{"location":"Manual/#2-save-process","title":"2. Save Process","text":"<p>When a save is requested via <code>RequestGameSave</code>, the system initiates a Data Collection Phase:</p> <ul> <li>Background Dispatch The <code>OnSaving</code> event is dispatched on a background thread. This ensures that the serialisation of hundreds of objects doesn't cause any stutter during gameplay.</li> <li>Data Collection Every subscribed persistable object (scripts and actors) write their data into the shared <code>Dictionary&lt;Guid, string&gt;</code>, provided via the <code>OnSaving</code> event</li> <li>Finalization Once the data is collected, the <code>SaveManager</code> writes the data to disk and creates a new <code>SaveMeta</code> entry</li> </ul>"},{"location":"Manual/#3-load-process","title":"3. Load Process","text":"<p>When a game load is requested via <code>RequestGameLoad</code>, the system works in the background, until the save data ready for processing:</p> <ul> <li>Asynchronouse Read The requested file is read from disk in the background</li> <li>Notification Once the data is ready in memory, the <code>OnLoaded</code> event is dispatched for further loading operations, like scene loading</li> <li>Data Distribution Persistable objects retrieve their specific data using <code>GetSaveData</code> during their initilization (i.e. <code>OnEnabled</code>, <code>OnStart</code>)</li> </ul>"},{"location":"Manual/#best-practices-safety","title":"Best Practices &amp; Safety","text":"<p>Thread &amp; Scene Safety</p> <p>Since data collection happens in a background thread, never modify the scene via the <code>OnSaving</code> event. Treat your objects as Read-Only. Modifying actor properties or spawning object will be rejected by the engine.</p> <ul> <li>UI &amp; Scene Updates For UI notifications or scene transitions, use the main-thread safe callbacks <code>OnSaved</code>, <code>OnLoaded</code> and <code>OnDeleted</code>.</li> <li>Convenience For one-off tasks, like closing a menu after save or loading scenes after load, use the invoke helpers <code>InvokeOnSaved</code>, <code>InvokeOnLoaded</code> and <code>InvokeOnDeleted</code>.</li> <li>ID-Based Save data is indexed by a <code>Guid</code>. For scripts and actors, the build-in <code>ID</code> property is the most reliable way to ensure data maps back to the correct object. These ids are unique (yes, for spawned prefabs, too), persistent and handled automatically by Flax.</li> </ul>"},{"location":"Manual/AutoSave/","title":"Auto-Saves in Production Workflow","text":"<p>The built-in auto-save feature is perfect for prototyping, but game productions often require more control about timing and data. </p> <p>You might want to attach project-specific metadata to an auto-save, change the save interval, or trigger auto-saves at specific Checkpoints.</p> <p>In this section, we'll take a look on how to create a custom auto-save feature, that suits project-specific needs.</p>"},{"location":"Manual/AutoSave/#core-concepts","title":"Core Concepts","text":""},{"location":"Manual/AutoSave/#timers-triggers","title":"Timers &amp; Triggers","text":"<p>You can use two approaches to auto-save timers.</p> <ul> <li>You can keep the <code>SaveSettings</code> interval for auto-saves, but listen to a \"Can I save now?\" condition in your games logic.</li> <li>Ignore any <code>SaveSettings</code> and create an internal timer in your games logic. This provides full control and customizablilty via the games UI.</li> </ul> <p>For triggers (i.e. Checkpoints), you can simply call <code>RequestGameSave</code>, when entering a trigger volume.</p>"},{"location":"Manual/AutoSave/#the-auto-save-flag","title":"The Auto-Save Flag","text":"<p>When calling <code>RequestGameSave</code> via the game logic, the <code>IsAutoSave</code> will never be <code>true</code>. This is because the built-in <code>IsAutoSave</code> can only be written to by the built-in auto-save feature. Use the Custom Metadata approach in the next section, to handle your custom games auto-save flags.</p>"},{"location":"Manual/AutoSave/#custom-metadata-for-auto-saves","title":"Custom Metadata for Auto-Saves","text":"<p>Just like manual saves, auto-saves benefit greatly from custom metadata. Storing a quest-title or a location name helps players recognize where they are returning to.</p> <p>FlaxSave provides a straight-forward integration to attach additional information to a <code>SaveMeta</code> entry.</p> <p>Custom Metadata Guide</p> <p>Checkout the Custom Metadata Guide for more information.</p>"},{"location":"Manual/AutoSave/#defining-your-metadata","title":"Defining your Metadata","text":"<p>To store custom information, create a simple <code>class</code> that wraps the data you can to attach to your saves.</p> C#<pre><code>public class MySaveInfo\n{\n    public string LocationName;\n    public int PlayerLevel;\n    public bool AutoSave;\n}\n</code></pre>"},{"location":"Manual/AutoSave/#attaching-data-during-save","title":"Attaching Data during Save","text":"<p>When you request a save, you can pass your custom <code>class</code> object directly into the <code>RequestGameSave</code> method. The <code>SaveManager</code> will serialize the <code>class</code> and store it inside the <code>SaveMeta</code> file.</p> C#<pre><code>public void SaveTheGame()\n{\n    var customInfo = new MySaveInfo()\n    {\n        LevelName = \"The Darkest Dungeon\",\n        PlayerLevel = 5,\n        AutoSave = true\n    };\n\n    // This data is now attached to the savegames metadata\n    SaveManager.Instance.RequestGameSave(\"My Save\", customInfo);\n}\n</code></pre>"},{"location":"Manual/AutoSave/#checkout-custom-data","title":"Checkout custom Data","text":"<p>You can access your data directly from a <code>SaveMeta</code> entry. Use the <code>GetCustomData&lt;T&gt;()</code> method to safely cast the stored object back into your data class.</p> C#<pre><code>public void BuildLoadMenu()\n{\n    foreach (SaveMeta meta in SaveManager.Instance.SaveMetas)\n    {\n        // Extract the custom data\n        var customInfo = meta.GetCustomDataAs&lt;MySaveInfo&gt;();\n\n        if (customInfo != null)\n            Debug.Log($\"Is Auto Save: {customInfo.AutoSave} | Level: {customInfo.PlayerLevel}\");\n\n    }\n}\n</code></pre> <p>Performance</p> <p>Custom metadata is stored as a JSON-string within the small <code>.meta</code> file. Because this file is separate from the large savegame files, you can create rich, informative save lists with zero lag.</p>"},{"location":"Manual/AutoSave/#step-by-step","title":"Step-By-Step","text":""},{"location":"Manual/AutoSave/#disable-the-auto-save","title":"Disable the Auto-Save","text":"<p>In your <code>SaveSettings</code>, uncheck <code>Auto Save</code>. The <code>SaveManger</code> will now remain idle until your game logic explicity requests a save.</p>"},{"location":"Manual/AutoSave/#create-timer-logic","title":"Create Timer Logic","text":"<p>If you want to keep the convinience of a timer, but add custom information to a <code>SaveMeta</code> entry, you can implement a simple controller script.</p> C#<pre><code>public class AutoSaveController : Script\n{\n    public float SaveIntervalMinutes = 5.0f;\n    private float timer;\n\n    public override void OnUpdate()\n    {\n        timer += Time.DeltaTime;\n\n        if (SaveIntervalMinutes * 60 &lt;= timer)\n        {\n            if (CanSaveNow())\n            {\n                TriggerAutoSave();\n                timer = 0;\n            }\n        }\n    }\n\n    private bool CanSaveNow()\n    {\n        // Add your custom logic here\n        // i.e. check if the player is in combat or a dialogue\n        return !Player.Instance.IsInCombat;\n    }\n\n    private void TriggerAutoSave()\n    {\n        // UI Notification, which will show AFTER the game is saved\n        SaveManager.Instance.InvokeOnSaved(() =&gt; {\n            Debug.Log(\"Game Saved!\");\n        });\n\n        var info = new MySaveInfo() \n        { \n            AutoSave = true, \n            LocationName = \"Wilderness\" \n        };\n\n        SaveManager.Instance.RequestGameSave(\"Auto-Save\", info);\n    }\n}\n</code></pre> <p>Persistent Auto-Save Controller</p> <p>Consider using the Flax Engines <code>GamePlugin</code> type, instead of <code>Script</code> for a session persistent auto-save controller.</p>"},{"location":"Manual/AutoSave/#create-checkpoint-logic","title":"Create Checkpoint Logic","text":"<p>Create a script that detects the player and tells the <code>SaveManger</code> to performa a save with your custom metadata.</p> C#<pre><code>public class CheckpointTrigger : Script\n{\n    public string AreaName = \"The Dungeon Entrance\";\n    private bool alreadyTriggered = false;\n\n    public void OnTriggerEnter(PhysicsColliderActor collider)\n    {\n        // Ensures the player only triggers once\n        if(alreadyTriggered == true || collider is not CharacterController)\n            return;\n\n        alreadyTriggered = true;\n\n        var myInfo = new MySaveInfo()\n        {\n            LocationName = AreaName,\n            AutoSave = true\n        };\n\n        // Creates a savegame with the custom info\n        SaveManager.Instance.RequestGameSave(\"Auto-Save\", myInfo);\n    }\n\n    public override void OnEnable()\n    {\n        // Register for the trigger enter event\n        Actor.As&lt;Collider&gt;().TriggerEnter += OnTriggerEnter;\n    }\n\n    public override void OnDisable()\n    {\n        // Don't forget to unsubscribe from events!\n        Actor.As&lt;Collider&gt;().TriggerEnter -= OnTriggerEnter;\n    }\n}\n</code></pre>"},{"location":"Manual/AutoSave/#best-practices","title":"Best Practices","text":"<ul> <li>Player State Before triggering an auto-save, check if the player is in a \"safe\" state. Avoid saving, while the player is falling into a pit or in the middle of a death animation, to prevent death loops.</li> <li>Save Throttling If you use a timer-based approch, ensure you don't save during level load loading or during conversation with NPCs.</li> <li>Visual Feedback Use the <code>InvokeOnSaved</code> method, to display a subtle \"Checkpoint Reached\" or \"Game Saved\" notification in your UI, to let players know their progress is secure.</li> </ul>"},{"location":"Manual/CustomMeta/","title":"Custom Metadata for Save Files","text":"<p>While the default <code>SaveMeta</code> provides the basics (Name, Date/Time, etc.), most games require more specific information to show in a Save-Slot UI, and developers benefit greatly from introducing custom metadata.</p> <p>FlaxSave provides a straight-forward integration to attach additional information (i.e. player location, current skill level or quest progression) to a <code>SaveMeta</code> entry.</p>"},{"location":"Manual/CustomMeta/#core-concepts","title":"Core Concepts","text":""},{"location":"Manual/CustomMeta/#built-in-custom-metadata","title":"Built-in &amp; Custom Metadata","text":"<p>A save slot usually needs more than just a name. We differentiate between</p> <ul> <li>Default Data Save Name, Display Name, Date/Time and the <code>IsAutoSave</code> flag</li> <li>Custom Data Project specifc info, like \"Current Location\", \"Player Level\", \"Completion Percentage\"</li> </ul>"},{"location":"Manual/CustomMeta/#performance-and-access","title":"Performance and Access","text":"<ul> <li>Performance Listing 100 saves is nearly instant, because the heavy savegames stay on disk.</li> <li>Access All discovered saves are available via <code>SaveManager.Instance.SaveMetas</code></li> </ul>"},{"location":"Manual/CustomMeta/#step-by-step","title":"Step-By-Step","text":""},{"location":"Manual/CustomMeta/#custom-data-class","title":"Custom Data Class","text":"<p>Use a custom <code>class</code> for the project-specific values you want to store. </p> C#<pre><code>public class MySaveInfo\n{\n    public string LocationName;\n    public int PlayerLevel;\n    public float CompletionPercentage;\n    public bool AutoSave;\n}\n</code></pre>"},{"location":"Manual/CustomMeta/#attaching-data-during-save","title":"Attaching Data during Save","text":"<p>When you request a save, you can pass your custom <code>class</code> object directly into the <code>RequestGameSave</code> method. The <code>SaveManager</code> will serialize the <code>class</code> and store it inside the <code>SaveMeta</code> file.</p> C#<pre><code>public void SaveTheGame()\n{\n    var customInfo = new MySaveInfo()\n    {\n        LevelName = \"The Darkest Dungeon\",\n        PlayerLevel = 5,\n        CompletionPercentage = 42.7f,\n        AutoSave = false\n    };\n\n    // This data is now attached to the savegames metadata\n    SaveManager.Instance.RequestGameSave(\"My Save\", customInfo);\n}\n</code></pre>"},{"location":"Manual/CustomMeta/#retrieving-data","title":"Retrieving Data","text":"<p>You can access your data directly from a <code>SaveMeta</code> entry. Use the <code>GetCustomData&lt;T&gt;()</code> method to safely cast the stored object back into your data class.</p> C#<pre><code>public void BuildLoadMenu()\n{\n    foreach (SaveMeta meta in SaveManager.Instance.SaveMetas)\n    {\n        // Extract the custom data\n        var customInfo = meta.GetCustomDataAs&lt;MySaveInfo&gt;();\n\n        if (customInfo != null)\n        {\n            // Update your UI elements\n            Debug.Log($\"Location: {customInfo.LevelName} | Level: {customInfo.PlayerLevel}\");\n        }\n    }\n}\n</code></pre> <p>Performance</p> <p>Custom metadata is stored as a JSON-string within the small <code>.meta</code> file. Because this file is separate from the large savegame files, you can create rich, informative save lists with zero lag.</p>"},{"location":"Manual/Examples/","title":"Example Scripts","text":""},{"location":"Manual/GameUI/","title":"Metadata &amp; UI Integration","text":"<p>This section explains how to use the <code>SaveMeta</code> class to build a Save/Load menu. You'll learn how to display save information to the player without the performance cost of loading the actual save data.</p>"},{"location":"Manual/GameUI/#core-concepts","title":"Core Concepts","text":""},{"location":"Manual/GameUI/#the-metadata-snapshot","title":"The Metadata Snapshot","text":"<p>When the <code>SaveManager</code> initializes, it doesn't load save data, but it only retrieves the small header objects called <code>SaveMeta</code>.</p> <ul> <li>Performance Listing 100 saves is nearly instant, because the heavy savegames stay on disk.</li> <li>Access All discovered saves are available via <code>SaveManager.Instance.SaveMetas</code></li> </ul>"},{"location":"Manual/GameUI/#built-in-custom-metadata","title":"Built-in &amp; Custom Metadata","text":"<p>A save slot usually needs more than just a name. We differentiate between</p> <ul> <li>Default Data Save Name, Display Name, Date/Time and the <code>IsAutoSave</code> flag</li> <li>Custom Data Project specifc info, like \"Current Location\", \"Player Level\", \"Completion Percentage\"</li> </ul>"},{"location":"Manual/GameUI/#custom-metadata","title":"Custom Metadata","text":"<p>While the default <code>SaveMeta</code> provides the basics (Name, Date/Time, etc.), most games require more specific information to show in a Save-Slot UI.</p> <p>FlaxSave provides a straight-forward integration to attach additional information (i.e. player location, current skill level or quest progression) to a <code>SaveMeta</code> entry.</p> <p>Custom Metadata Guide</p> <p>Checkout the Custom Metadata Guide for more information.</p>"},{"location":"Manual/GameUI/#defining-your-metadata","title":"Defining your Metadata","text":"<p>To store custom information, create a simple <code>class</code> that wraps the data you want to show in your Save-Slot UI.</p> C#<pre><code>public class MySaveInfo\n{\n    public string LocationName;\n    public int PlayerLevel;\n    public float CompletionPercentage;\n}\n</code></pre>"},{"location":"Manual/GameUI/#attaching-data-during-save","title":"Attaching Data during Save","text":"<p>When you request a save, you can pass your custom <code>class</code> object directly into the <code>RequestGameSave</code> method. The <code>SaveManager</code> will serialize the <code>class</code> and store it inside the <code>SaveMeta</code> file.</p> C#<pre><code>public void SaveTheGame()\n{\n    var customInfo = new MySaveInfo()\n    {\n        LevelName = \"The Darkest Dungeon\",\n        PlayerLevel = 5,\n        CompletionPercentage = 42.7f\n    };\n\n    // This data is now attached to the savegames metadata\n    SaveManager.Instance.RequestGameSave(\"SaveSlot_01\", customInfo);\n}\n</code></pre>"},{"location":"Manual/GameUI/#retrieving-data-for-the-ui","title":"Retrieving Data for the UI","text":"<p>When building your load menu, you can access your data directly from a <code>SaveMeta</code> entry. Use the <code>GetCustomData&lt;T&gt;()</code> method to safely cast the stored object back into your data class.</p> C#<pre><code>public void BuildLoadMenu()\n{\n    foreach (SaveMeta meta in SaveManager.Instance.SaveMetas)\n    {\n        // Extract the custom data\n        var customInfo = meta.GetCustomDataAs&lt;MySaveInfo&gt;();\n\n        if (customInfo != null)\n        {\n            // Update your UI elements\n            Debug.Log($\"Location: {customInfo.LevelName} | Level: {customInfo.PlayerLevel}\");\n        }\n    }\n}\n</code></pre> <p>Performance</p> <p>Custom metadata is stored as a JSON-string within the small <code>.meta</code> file. Because this file is separate from the large savegame files, you can create rich, informative save lists with zero lag.</p>"},{"location":"Manual/GameUI/#building-ui-notifications","title":"Building UI &amp; Notifications","text":"<p>In this example, we're going to build an endless, dynamic list of save-slots which are a staple of RPGs, Survival and Simulation games.</p> <p>Every slot in the list is a UI Widget linked to a specific <code>SaveMetas</code> entry.</p> <p>Ready-to-use Examples</p> <p>You can find the complete implementation in the plugin folder:</p> <ul> <li>Widget Prefab in <code>FlaxSave &gt; Content &gt; Example</code></li> <li>Logic &amp; Scripts in <code>FlaxSave &gt; Source &gt; FlaxSaveExamples</code></li> </ul>"},{"location":"Manual/GameUI/#1-create-a-ui-widget","title":"1. Create a UI Widget","text":"<p> For this example, the UI Widget consists of a <code>Button</code>, with three <code>Label</code> children. The labels will display:</p> <ul> <li><code>DisplayName</code></li> <li><code>SaveVersion</code></li> <li><code>SaveDate</code></li> </ul> <p>Convert the setup into a prefab.</p>"},{"location":"Manual/GameUI/#2-create-the-save-slot-logic","title":"2. Create the Save-Slot Logic","text":"<p>Create and attach a script (i.e. <code>SaveSlot</code>) to your Widget prefab. This script will fill the UI with the data from a <code>SaveMeta</code> object and handle the click event, to trigger a savegame load.</p> C#<pre><code>public class SaveSlot : Script\n{\n    public ControlReference&lt;Button&gt; LoadButton;\n    public ControlReference&lt;Label&gt; SavetTitelLabel;\n    public ControlReference&lt;Label&gt; VersionLabel;\n    public ControlReference&lt;Label&gt; DateLabel;\n\n    private SaveMeta saveMeta;\n\n    // Sets up the ui\n    public void Bind(SaveMeta metaData)\n    {\n        saveMeta = metaData;\n\n        // The friendly name of the savegame\n        SavetTitelLabel.Control.Text = saveMeta.DisplayName;\n\n        // Display the savegame Version\n        VersionLabel.Control.Text = saveMeta.SaveVersion.ToString();\n\n        // Display the time and date, when this savegame was created\n        DateTime localTime = saveMeta.SaveDate.ToLocalTime();\n        DateLabel.Control.Text = localTime.ToString(\"g\");\n\n        // Subscribe to the button clicked event\n        LoadButton.Control.Clicked += LoadSave;\n    }\n\n    // Request a savegame load with the SaveName from the associated save meta\n    public void LoadSave()\n    {\n        SaveManager.Instance.RequestGameLoad(saveMeta.SaveName);\n    }\n\n    public override void OnDisable()\n    {\n        // Don't forget to unsubscribe from events!\n        LoadButton.Control.Clicked -= LoadSave;\n        base.OnDisable();\n    }\n}\n</code></pre> <p>Remember to save changes to your prefab.</p>"},{"location":"Manual/GameUI/#3-scene-setup","title":"3. Scene Setup","text":"<p> For the list in the UI itself, create a <code>UICanvas</code> and add a child <code>UIControl</code> with the type set to <code>VerticalPanel</code>. </p> <p>The advantage of a <code>VerticalPanel</code> is that it handles the layout for you: all children (your Save-Slot Widgets) will automatically be arranged into a clean vertical list as they are spawned.  This keeps your UI organized and responsive without manual positioning.</p>"},{"location":"Manual/GameUI/#4-create-the-list-logic","title":"4. Create the List Logic","text":"<p>Create and attach a script (i.e. <code>SaveListManager</code>) to the <code>VerticalPanel</code> control.</p> <p>This script spawns the UI Widgets as children of a <code>VerticalPanel</code>. To keep the UI in sync with the <code>SaveMetas</code>, we use the <code>OnSaved</code> and <code>OnDeleted</code> events.</p> C#<pre><code>public class SaveListManager : Script\n{\n    public Prefab Widget;\n    public ControlReference&lt;VerticalPanel&gt; ListContainer;\n\n\n    // Instantiates UI widgets with meta infos about savegames\n    public void SpawnWidgets()\n    {\n        // Clear everything to avoid double entries\n        Actor.DestroyChildren();\n\n        // Instance a widget for every SaveMeta entry in the SaveManager.\n        for (int i = 0; i &lt; saveManager.SaveMetas.Count; i++)\n        {\n            Actor newWidget = PrefabManager.SpawnPrefab(Widget, ListContainer);\n            newWidget.GetScript&lt;SaveSlot&gt;()?.Bind(saveManager.SaveMetas[i]);\n        }\n    }\n\n\n    public override void OnEnable()\n    {\n        saveManager = SaveManager.Instance;\n\n        // Automatically refreshes UI when as save is created or deleted\n        SaveManager.Instance.OnSaved += SpawnWidgets;\n        SaveManager.Instance.OnDeleted += SpawnWidgets;\n\n        // Initial build of the UI\n        SpawnWidgets();\n    }\n\n    public override void OnDisable()\n    {\n        // Don't forget to unsubscribe your methods from events!\n        SaveManager.Instance.OnSaved -= SpawnWidgets;\n        SaveManager.Instance.OnDeleted -= SpawnWidgets;\n    }\n}\n</code></pre> <p>Whenever you request a game save or an auto-save happens, the Save-Slot UI will automatically update and you can click the <code>Button</code> of the UI Widget to load a previous game state.</p>"},{"location":"Manual/GameUI/#best-practices","title":"Best Practices","text":""},{"location":"Manual/GameUI/#notifications","title":"Notifications","text":"<p>Since data collection happens in the background, trying to show a a \"Game Saved!\" notification directly inside <code>OnSaving</code> will be rejected by the engine. </p> <p>Use the <code>InvokeOnSaved</code> helper to trigger notifications, as the helper waits for the background work to finish, before executing any action on the main-thread. </p> <p>The same concept goes for <code>InvokeOnLoaded</code> and <code>InvokeOnDeleted</code>.</p> C#<pre><code>public void QuickSave()\n{\n    // This ensures the notification happens on the UI thread\n    // only AFTER the file is safely written to disk.\n    SaveManager.Instance.InvokeOnSaved(() =&gt; {\n        Debug.Log(\"Game Saved successfully!\");\n    });\n\n    SaveManager.Instance.RequestGameSave(\"QuickSave\");\n}\n</code></pre>"},{"location":"Manual/GameUI/#ui-refreshing","title":"UI Refreshing","text":"<p>Don't refresh your UI list every frame. Only rebuild the list, when something actually changes. By subscribing to the <code>SaveManager events</code>,  your UI stays reactive without wasting performance.</p> <ul> <li><code>OnSaved</code>: Refresh, when a new save is created.</li> <li><code>OnDeleted</code>: Refresh, when a save is removed (to avoid ghost-slots)</li> <li><code>OnLoaded</code>: Close the menu and trigger scene transition, once the data is ready</li> </ul>"},{"location":"Manual/GameUI/#localization","title":"Localization","text":"<p>Use <code>Localization Keys</code> in the <code>SaveMeta.DisplayName</code> for automated entries, like auto-saves and quick-saves. By using a <code>LocalizationString</code>, you can attempt to translate these keys, while still gracefully falling back to the raw string, if the user provided a custom name for a manual save.</p> C#<pre><code>public void Bind(SaveMeta metaData)\n{\n    // This tries to return the localized version of DisplayName.\n    // If no localization key matches, it falls back to the raw value.\n    var displayText = new LocalizationString()\n    { \n        Id = metaData.DisplayName, \n        Value = metaData.DisplayName \n    };\n\n    SavetTitelLabel.Control.Text = displayText;\n}\n</code></pre> <p></p> <p>When displaying the <code>SaveDate</code>, use the C# built-in formatting and <code>ToLocalTime</code>, to respect the user's regional settings and time zone.</p> C#<pre><code>// Simple. Uses the general date/time pattern (i.e. 01/01/2026 3:00 PM)\nDateLabel.Control.Text = metaData.SaveDate.ToLocalTime().ToString(\"g\");\n\n// Advanced. Full control using the games current culture setting\nDateTime localTime = metaData.SaveDate.ToLocalTime();\n\nstring date = localTime.ToString(\"d\", Localization.CurrentCulture);\nstring time = localTime.ToString(\"t\", Localization.CurrentCulture);\n\nDateLabel.Control.Text = date + \", \" + time;\n</code></pre>"},{"location":"Manual/GameUI/#empty-saves","title":"Empty Saves","text":"<p>Always handle the \"No Saves Found\" cases. If <code>SaveManager.Instance.SaveMetas.Count == 0</code>, display a simple label saying \"No saves found!\". It's a small detail that makes the UI feel finished.</p>"},{"location":"Manual/GlobalAssets/","title":"Global Assets (ISavableAsset)","text":"<p>While scripts and actors handle data within a scene, <code>ISavableAsset</code> assets are designed for global configuration and persistent project data. These are JSON Assets that live in your content folder and stay active across scene changes and savegame states.</p>"},{"location":"Manual/GlobalAssets/#core-concepts","title":"Core Concepts","text":""},{"location":"Manual/GlobalAssets/#full-instance-serialization","title":"Full Instance Serialization","text":"<p>Unlike the manual <code>SetSaveData</code> approach for scripts, <code>ISavableAsset</code> uses Deep Serialization. This means the <code>SaveManager</code> saves the entire state of the asset object.</p> <ul> <li>Every public field or property marked for serialization is automatically captured.</li> <li>When loading, the asset in your project is updated with the saved values.</li> </ul>"},{"location":"Manual/GlobalAssets/#the-bridge-pattern","title":"The \"Bridge\" Pattern","text":"<p>Because these assets persist, they act as a bridge between your game logic and the engine configuration. You should use the two interface methods to sync your data.</p> <ul> <li><code>SaveAction</code>: Pushes the current engine state or manager variables into the asset.</li> <li><code>LoadAction</code>: Pulls the loaded values from the asset and applies them back to the engine.</li> </ul> C#<pre><code>public class AudioSettings : ISavableAsset\n{\n    public bool EnableHRTF;\n\n    public void SaveAction()\n    {\n        // Sync engine state to asset before saving to disk\n        EnableHRTF = Audio.EnableHRTF;\n    }\n\n    public void LoadAction()\n    {\n        // Apply loaded values back to the engine\n        Audio.EnableHRTF = EnableHRTF;\n    }\n}\n</code></pre>"},{"location":"Manual/GlobalAssets/#when-to-use-assets-vs-scripts","title":"When to use Assets vs. Scripts","text":"<p>Choosing the right tool is key for a clean project architecture.</p> Feature Use <code>ISavableAsset</code>, when... Use <code>Script/Actor</code>, when... Scope Data is Global (Settings, Achievements, Total Playtime) Data is Local (Player Health, Active Quest, Door State) Lifetime Needs to be available before a scene loads Only exists while a specific scene is active <p>Static Assets vs. Instances</p> <p>Do not use <code>ISavableAsset</code> for things like <code>Enemy Stats</code> or <code>Quest Progession</code>. If you modifiy a JSON asset, the change will persist permanently thru save wipes (Savegame load, New Game, New Game+) and may cause unwanted behaviour. </p> <p>For these cases (i.e. <code>Enemy Stats</code>, <code>Player Stats</code>, <code>Quest Progession</code>), always use the script-based saving approach to save the state of individual json assets to the current savegame.</p> <p><code>ISavableAsset</code> is perfect for configuration assets. These are assets you register in your <code>SaveSettings</code>.</p> <ul> <li>Config Assets Automatically loaded on startup. Ideal for Graphics, Audio, Input, etc.</li> <li>Scene Data Strictly bound to the <code>RequestGameLoad</code> flow. Ideal for everything that happens inside the gameplay loop.</li> </ul>"},{"location":"Manual/GlobalAssets/#step-by-step","title":"Step-By-Step","text":"<ol> <li> <p>Prepare your Modules</p> <p>Make sure to add the FlaxSave dependency to the <code>*.Build.cs</code> file in any module, where you want to use FlaxSave</p> C#<pre><code>options.PublicDependencies.Add(nameof(FlaxSave));\n// or\noptions.PublicDependencies.Add(\"FlaxSave\");\n</code></pre> </li> <li> <p>Create a Class</p> <p>This class will act as a template for your JSON asset. Choose a clearly identifiable name.</p> </li> <li> <p>Implementation</p> <p>Derive your class from the <code>ISavableAsset</code> interface and implement the required methods. This example handles screen resolution and v-sync.</p> C#<pre><code>using FlaxEngine;\nusing FlaxSave;\n\npublic class SavableGraphics : ISavableAsset\n{\n    public Float2 ScreenSize;\n    public bool UseVSync;\n\n    public void SaveAction()\n    {\n        // Sync engine state to asset before saving to disk\n        ScreenSize = Screen.Size;\n        UseVSync = Graphics.UseVSync;\n    }\n\n    public void LoadAction()\n    {\n        // Apply loaded values back to the engine\n        Screen.Size = ScreenSize;\n        Graphics.UseVSync = UseVSync;\n    }\n}\n</code></pre> </li> <li> <p>Content Asset      Go to your projects content window and <code>right click &gt; New &gt; Json Asset</code></p> <p> Select your class in the creation dialogue.</p> </li> <li> <p>Register your Asset</p> <p></p> <p><code>ISavableAsset</code> need to be registered to be managed by the <code>SaveManager</code>. Drag your new asset in the <code>Assets</code> list within the <code>SaveSettings</code>.</p> </li> <li> <p>Save &amp; Load</p> <p>Use <code>RequestAssetSave</code> and <code>RequestAssetLoad</code> to save and load asset states.</p> <p>Note that <code>RequestAssetLoad</code> is automatically executed on startup.</p> <p>Editor protection</p> <p>To prevent accidental data loss while working in the Flax Editor, automatic assets loading is disabled by default during edit-time. This behaviour can be configured in SaveSettings asset</p> </li> </ol>"},{"location":"Manual/Installation/","title":"Installation &amp; Setup","text":"<p>FlaxSave is designed to be Plug&amp;Play. Once the plugin is installed into your project, you only need to link a settings asset to begin using the save system.</p>"},{"location":"Manual/Installation/#installation","title":"Installation","text":""},{"location":"Manual/Installation/#requirements","title":"Requirements","text":"<ul> <li>FlaxEngine <code>v. 1.11</code> or above</li> <li>Git Installed and configured, for the The Easy Way method</li> </ul>"},{"location":"Manual/Installation/#plugin-installation","title":"Plugin Installation","text":""},{"location":"Manual/Installation/#the-easy-way","title":"The Easy Way","text":"<ul> <li>In the Flax Editor, go to <code>Tools &gt; Plugins &gt; Clone Project</code></li> <li>Paste this repo link <code>https://github.com/Myterian/FlaxSave.git</code> into the <code>Git Path</code></li> <li>Click <code>Clone</code></li> <li>Restart the Editor</li> <li>Done</li> </ul>"},{"location":"Manual/Installation/#manual-installation","title":"Manual Installation","text":"<ul> <li>Close the Editor</li> <li>Clone the FlaxSave repo into <code>&lt;your-game-project-folder&gt;\\Plugins\\FlaxSave\\</code></li> <li>Add a reference to FlaxEvent to your game, by modifying the <code>&lt;your-game&gt;.flaxproj</code> file <pre><code>...\n\"References\": [\n    {\n        \"Name\": \"$(EnginePath)/Flax.flaxproj\"\n    },\n    {\n        \"Name\": \"$(ProjectPath)/Plugins/FlaxSave/FlaxSave.flaxproj\"\n    }\n]\n...\n</code></pre></li> <li>Restart the Editor</li> <li>Done</li> </ul>"},{"location":"Manual/Installation/#setup","title":"Setup","text":"<p>After successfull installation, you can tell the engine which configuration to use. Without this step, FlaxSave will use its Default Settings. The default settings are great for prototyping, but may not satify your project needs during production.</p>"},{"location":"Manual/Installation/#1-create-the-settings-asset","title":"1. Create the Settings Asset","text":"<p>In your Content Window, right-click and select <code>New &gt; FlaxSave &gt; Save Settings</code>.</p>"},{"location":"Manual/Installation/#2-register-with-gamesettings","title":"2. Register with GameSettings","text":"<p>To activate your configuration, the save settings asset must be registered in the global <code>GameSettings</code>.</p> <ol> <li>Open your projects <code>GameSettings</code></li> <li>Navigate to <code>Other Settings &gt; Custom Settings</code></li> <li>Create a new entry with the save settings asset</li> </ol> <p>Project Versioning</p> <p>Open your save settings asset and set your initial <code>Savegame Version</code>. This ensure that even your first playtests savegames are correctly versioned.</p>"},{"location":"Manual/Installation/#3-alternative-settings","title":"3. Alternative Settings","text":"<p>Once linked, the <code>SaveManager</code> will automatically detect these settings on startup. For rapid testing, you can create more save settings assets with unique configurations, because only the save settings asset linked in <code>GameSettings</code> will affect the system.</p>"},{"location":"Manual/SaveSettings/","title":"Save Settings","text":"<p>The save settings asset is the central configuration hub for the FlaxSave system. It defines how and when your game data is stored.</p> <p></p>"},{"location":"Manual/SaveSettings/#configuration-properties","title":"Configuration Properties","text":"Section Property Description Meta Savegame Version The version of your data scheme. Increment this, when you make breaking changes to your save data structure to handle migration. Savegame File Extension The file extension used for all save files. Auto Save Auto Save Enables or disables the built-in auto-save feature. Auto Save Intervals Minutes How often the system triggers an auto save. Minimum: 1 Minute. Savable Assets Skip Loading Assets in Editor If enabled, ISavableAssets won't load their stored values while you are in the Editor. This prevents your project assets from being permanently overwritten by accident. Assets The registry for all <code>ISavableAsset</code> instances. Drag your assets here to, so the <code>SaveManager</code> can manage them."},{"location":"Manual/SaveSettings/#utility-buttons","title":"Utility Buttons","text":""},{"location":"Manual/SaveSettings/#open-directory","title":"Open Directory","text":"<p>Clicking this button opens your OS file browser directly at the path where your save games are currently stored.</p> <p>Editor vs. Game Saves</p> <p>Savegames created from the editor are located at a different directory, than savegames created from a cooked game. You can use the OpenDirectory method to always open the correct save directory.</p>"},{"location":"Manual/SaveSettings/#how-to-use-multiple-settings","title":"How to use multiple Settings","text":"<p>You can create multiple save settings assets for different purposes (i.e. <code>DebugSettings</code> with a 1 minute auto-save and <code>ReleaseSettings</code> with a 10 minute interval).</p> <p>To switch between them, simply change the reference in your <code>GameSettings &gt; Custom Settings</code>.</p>"},{"location":"Manual/SavingLoading/","title":"How to create persistable Objects","text":"<p>This section covers the standard workflow for making any script or actor in your scene persistable.  Whether it's the players position, health, a door's open state or an npcs inventory.  The process always follows the same pattern.</p>"},{"location":"Manual/SavingLoading/#core-concepts","title":"Core Concepts","text":""},{"location":"Manual/SavingLoading/#subscription-model","title":"Subscription Model","text":"<p>Instead of the <code>SaveManager</code> searching thru a scene (which is slow), your scripts and actors opt-in to the save process.</p> <ul> <li>Use <code>OnEnable</code> to subscribe to <code>SaveManager</code> events</li> <li>Use <code>OnDisable</code> to unsubscribe (crucial to prevent issues)</li> </ul>"},{"location":"Manual/SavingLoading/#identity-id","title":"Identity (ID)","text":"<p>Every script and actor in Flax has a unique <code>Guid</code> (the <code>ID</code> property). Best practice is to use this as the \"key\" in the save dictionary.</p> <p>This ensures that when the game loads, the data finds its way back to the exact same object, even if you have multiple instances of the same prefab.</p> <p>Prefab Safety</p> <p>Flax instantiates every prefab with a unique <code>ID</code>. Using this property is the most robust way to identify save data and avoids prefabs overwriting each other.</p>"},{"location":"Manual/SavingLoading/#step-by-step","title":"Step-By-Step","text":"<p>To get the most flexibility out of FlaxSave, use scripts to handle saving and loading an actor state in a self-contained fashion. But the following steps can be directly applied to custom actors.</p> <ol> <li> <p>Prepare your Moduls</p> <p>Make sure to add the FlaxSave dependency to the <code>*.Build.cs</code> file in any module, where you want to use FlaxSave</p> C#<pre><code>options.PublicDependencies.Add(nameof(FlaxSave));\n// or\noptions.PublicDependencies.Add(\"FlaxSave\");\n</code></pre> </li> <li> <p>Create a script</p> <p>Like you would with any. Make sure to name it something you can easy identify.</p> </li> <li> <p>Loading Data</p> <p>The <code>OnEnable</code> method in your script is a good place to recreate the previously saved state of the attached actor.</p> <p>To retieve the data from the loaded savegame, you can simply call the <code>GetSaveData</code> method.</p> C#<pre><code>public override void OnEnable()\n{\n    string savedData = SaveManager.Instance.GetSaveData(ID);\n\n    if (string.IsNullOrEmpty(savedData))\n        return;\n\n    Transform transform = JsonSerializer.Deserialize&lt;Transform&gt;(savedData);\n    Actor.Transform = transform;\n}\n</code></pre> </li> <li> <p>Saving Data</p> <p>Saving data can be handled in two distinct ways, depending on whether you want to react to a global save request or manally update the state of an object.</p> <p></p> <p>Via the <code>OnSaving</code> event</p> <p>This is the standard way. Your scripts listen to the global save command and pushes its data into the shared dictionary.</p> C#<pre><code>public override void OnEnable()\n{\n    // Subscribe to the saving event\n    SaveManager.Instance.OnSaving += OnSaving;\n}\n\nprivate void OnSaving(Dictionary&lt;Guid, string&gt; savegame)\n{\n    // Write the actor's current rotation to the save dictionary\n    string data = JsonSerializer.Serialize(Actor.Orientation)\n    savegame[ID] = data;\n}\n\npublic override void OnDisable()\n{\n    // Unsubscribe to avoid memory leaks and other issues\n    SaveManager.Instance.OnSaving -= OnSaving;\n}\n</code></pre> <p></p> <p>Via <code>SetSaveData</code> (Manual updates)</p> <p>Sometimes you want to update the save data immediatly when something happens (i.e. a player picking up an item or an actor being disabled) rather than waiting for a global save request.</p> C#<pre><code>public override void OnDisable()\n{\n    // Manually write the actor's current rotation to the save dictionary\n    string data = JsonSerializer.Serialize(Actor.Orientation)\n    SaveManager.Instance.SetSaveData(ID, data);\n}\n</code></pre> </li> </ol>"},{"location":"Manual/SavingLoading/#common-setups","title":"Common Setups","text":"<p>FlaxSave is designed to handle anything from simple floats to complex custom classes. Here are the most common patterns.</p> <p>Example Scripts</p> <p>FlaxSave contains example scripts with common setups and pattern. You'll find them in the plugin folder  <code>FlaxSave &gt; Source &gt; FlaxSaveExamples &gt; Scripts</code></p>"},{"location":"Manual/SavingLoading/#complex-classes-or-structs","title":"Complex Classes or Structs","text":"<p>If you have multiple variables (i.e. health, stamina, mana) don't save them one by one. Create a small <code>struct</code> or <code>class</code> and save the whole object. The system will handle the JSON nesting for you.</p> C#<pre><code>public struct PlayerStats\n{\n    public float Health;\n    public int SkillLevel;\n}\n\n// During OnSaving event\nprivate void OnSaving(Dictionary&lt;Guid, string&gt; savegame)\n{\n    PlayerStats stats = new PlayerStats\n    {\n        Health = 89;\n        SkillLevel = 5;\n    };\n\n    savegame[ID] = JsonSerializer.Serialize(stats);\n}\n\n// Loading during actor initalization\npublic override void OnEnable()\n{\n    string data = SaveManager.Instance.GetSaveData(ID);\n    PlayerStats stats = JsonSerializer.Deserialize&lt;PlayerStats&gt;(data);\n    ...\n}\n</code></pre>"},{"location":"SomeFolder/somepage/","title":"Files Tille","text":""},{"location":"SomeFolder/somepage/#code-block","title":"Code Block","text":"MyTestScript.cs<pre><code>private int myInt = 10;\n\npublic int MyInt =&gt; myInt;\n\npublic int ReadMyInt()\n{\n    return myInt;\n}\n</code></pre>"}]}